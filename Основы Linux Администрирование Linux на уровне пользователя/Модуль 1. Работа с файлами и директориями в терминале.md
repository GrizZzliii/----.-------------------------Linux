![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/4f4748b57a4ca592f730ee7ddfd01ee2/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.1.svg)

# **О чём этот модуль**

Добро пожаловать в модуль, посвящённый работе с файлами и директориями в терминале.

Это только начало. Всё может выглядеть не очень сложным и важным, но точно поможет вам ориентироваться в системе. Да и в дальнейшем придётся часто работать с командами, приведёнными в этом модуле, ведь нужно будет редактировать конфигурации серверов, читать файлы логов системы, ставить новые пакеты, модернизировать ядро.

**После освоения модуля вы:**

*   Будете знать основные пользовательские команды для работы с файлами и директориями.
*   Будете понимать, как устроены утилиты командной строки и ключи к ним.
*   Научитесь работать в командной строке.
*   Освоите несколько команд, которые придётся постоянно использовать.

Мы будем работать с текстовой операционной системой. Первое время вы будете и совершать ошибки и, возможно, даже ломать операционную систему, но это не страшно. Как говорил Лао-цзы: «Даже путь в тысячу ли начинается с первого шага».

_В материалах вы можете встретить упоминания виртуальной частной сети (она же – VPN). При этом любое упоминание это не реклама, а возможность для нас качественно и в полном объеме оказать услугу. Знания и навыки, которые вы получаете в рамках курса, должны использоваться в соответствии с законами РФ. Мы не рекомендуем вам использовать ресурсы, которые запрещены в РФ._

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/cd8587281727f99f7d124e57bfb70301/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.2.svg)

С какой операционной системой вы работаете? Скорее всего, это _Windows_ или _Mac_ _OS_. За время изучения первого модуля вам будет необходимо подружиться с операционной системой _Linux._

## **Так что же такое Linux?**

> **Linux (GNU/Linux)** — это общее название _UNIX-_подобных операционных систем, созданных на основе ядра, которое свободно распространяется.

> **Ядро** — это программа, которая определяет работу ОС и обеспечивает взаимодействие между программным обеспечением и оборудованием.

Поскольку _Linux_ — это _open source-_операционная система, она существует в огромном количестве версий. Эти версии называются дистрибутивами.  

**_GNU/Linux_** не имеет определённой комплектации от производителя и поставляется в большом количестве дистрибутивов. Наиболее известными являются дистрибутивы _Debian, Ubuntu, Mint, Red Hat, CentOS._ Подробнее об отличиях можно прочитать [здесь](https://lifehacker.ru/distributivy-linux/).

_GNU_ — это свободная операционная система. Изначально для первых версий бралось ядро _Linux__,_ а в самом _Linux_ есть большое количество библиотек от проекта _GNU._ Поэтому прижилось такое совмещённое название. Но сейчас **приставку _GNU_** обычно не используют.

## **Немного истории**

В начале 80-х годов прошлого века программист Ричард Столман решил создать аналог _OS Unix,_ которая стала слишком сильно коммерциализирована, и исходный код системы стал закрытым. В связи с этим была разработана концепция свободного программного обеспечения. Основная мысль концепции в том, что пользователи должны иметь возможность модифицировать, создавать и обмениваться программами без ограничений. Эта идея и легла в основу Открытого лицензионного соглашения _GNU._

В начале 90-х годов программист из Финляндии Линус Торвальдс заинтересовался _OS Minix,_ которая была одной из версий _Unix._ Установив её на свой компьютер, он постепенно начал исправлять ошибки. В итоге через некоторое время он создал свою версию операционной системы, и в 1991 году выложил первую версию ядра для общего пользования. Сообщество приняло ядро очень тепло, и было предложено назвать ядро _Linux_ в честь самого создателя — Линуса. Обо всём этом можно подробнее прочитать в книге «_Just for fun_».

Исторически большая часть языков программирования родилась и продолжила развиваться в США, в том числе поэтому основным языком всей сферы _IT_ является английский. Большая часть ресурсов, посвящённых ПО и ОС, написана именно на английском языке. И так как львиную долю работы системного администратора составляет поиск и анализ информации, становится очевидно, что знание английского языка необходимо для успешного развития в профессии. В частности, в этом курсе мы будем работать со стандартной документацией _Linux,_ которая, конечно, будет представлена на английском языке.

Поэтому вам важно быть готовыми к тому, что придётся подтянуть свои знания английского языка и/или постоянно обращаться к переводчику/словарю.

Почему Linux популярен?

Подавляющее большинство пользователей _Linux_ — разработчики, инженеры, учёные и другого рода профессионалы. Они выбирают эту систему, поскольку:

*   под _Linux_ написаны тысячи специализированных программ;
*   при правильной настройке она быстрее, стабильнее и безопаснее, чем _Windows_ и _Mac_ _OS_;
*   в ней предусмотрен удобный механизм обновления — можно обновить только необходимые компоненты;
*   можно полностью настроить систему под свои вкусы.

### **В чём ещё преимущества Linux?**

*   **Бесплатность**. Практически все дистрибутивы распространяются бесплатно. Существует ряд платных дистрибутивов, но платные они потому, что выполняют специфические задачи плюс есть поддержка от компании-производителя. В данном обучении платные дистрибутивы затрагиваться не будут. Подавляющее большинство программ и серверов также распространяется бесплатно, и именно на таком софте работает большая часть интернета.
*   **Надёжность**. Дистрибутив _Linux_ можно установить на сервер, поднять на определённый объём программ и забыть о нём на годы, и он будет работать. И, скорее, железо выйдет из строя, чем сама операционная система. К тому же _Linux_, в отличие от _Windows_, меньше восприимчив к вирусам и более устойчив к взломам.
*   **Быстродействие**. За счёт большой возможности конфигурирования операционной системы её можно ускорить, убрав всё лишнее и добавив только нужное, пересобрав ядро и прочее, благодаря чему заточить его под одну определённую задачу. Например, если сервер будет исполнять только роль почтового, то ему в ядре не нужны модули, отвечающие за печать.

## **Отличия Linux от Windows**

Первое и главное отличие — это ядра операционных систем.

Исторически _Linux_ имеет монолитное ядро, первые ядра были именно такими. В современных операционных системах используется модульное ядро, но пока поговорим про монолитное. Оно состоит из одного файла, а если требуется расширить его функциональность, то надо использовать отдельные модули.

Конкретнее про то, как работает ядро, про модули и их подключение, а также сборку ядра будет рассказано в курсе далее.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/0b996dc2b47fc057b85b09fb5c7879c4/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.1.png)

Архитектура ядра _Linux_

Источник: [rtfm.co.ua](http://rtfm.co.ua/wp-content/uploads/2014/10/kernel_arch_2.jpg)

Как показано на схеме, пользовательские приложения (_User Application_) обращаются к ядру через интерфейс системных вызовов. Из-за этого все приложения существуют в отдельном пользовательском пространстве, то есть при каких-либо глобальных изменениях в программах не требуется перезагрузка. Например, графическая оболочка рабочего стола (как рабочий стол в _Windows)_ является внешним приложением, поэтому её можно сменить на лету, не перезагружая полностью всю операционную систему.

Когда только появились первые версии ядра _Linux,_ создатель ОС _Minix,_ профессор Эндрю Таненбаум, сказал, что монолитное ядро — это шаг назад в 70-е, и оно устарело уже на старте. Из-за этого у них с Торвальдсом случился спор, так как считалось, что будущее за микроядерной архитектурой. Но время показало, что монолитная архитектура не только выжила, но и вошла в массы.

Рассмотрим отличающееся ядро _Windows._

![img](https://cs8.pikabu.ru/post_img/2016/02/28/6/1456653478161419729.jpg)

Источник: [cs8.pikabu.ru](https://cs8.pikabu.ru/post_img/2016/02/28/6/1456653478161419729.jpg)

Заметно, что структура ядра намного сложнее. Приложения, подсистемы окружения и прочее обращаются через _Windows API_ к своим библиотекам, а уже они по своим закрытым внутренним протоколам через _Native API_ к _NTDLL.dll_, потом через диспетчер системных сервисов уходят в ядро.

## **Поговорим о файловой структуре**

В _Linux_ вся файловая структура начинается с _корневого раздела_, он обозначается косой чертой — `/`, её другое название — прямой слеш.

Все файлы сортируются по каталогам и зависят от типа.

Файлы конфигурации разных приложений находятся в `/etc`, домашняя директория для пользователей — это `/home`, исполняемые файлы и библиотеки находятся в `/usr` — системных ресурсах, а `/var` — изменяемые данные.

![img](https://www.softrew.ru/uploads/posts/2012-10/1349110893_linux-file-system.jpg)

Изображение примерной файловой структуры _Linux_

Источник: [www.softrew.ru](https://www.softrew.ru/uploads/posts/2012-10/1349110893_linux-file-system.jpg)

В _Linux_ жёсткие или виртуальные диски являются устройствами хранения и нумеруются по алфавиту, а разделы в них — цифрами.

Первый жёсткий диск будет называться _sda,_ второй — _sdb._ Разделы на них будут нумероваться с первого: _sda1, sda2, sda3._

Плюсы такой файловой системы в том, что разделы можно спокойно _примонтировать_ в любую нужную папку.

Немного уточним про монтирование, чтобы было понятнее: в давние времена, когда компьютеры были большие, а объёмы жестких дисков маленькие, и не было современных операционных систем, диски всегда подключали физически, то есть _примонтировали_. Исторически этот термин сохранился как, например, то, что знак сохранения обозначается дискетой, хотя ими никто уже не пользуется. В _Linux_ за монтирование дисков отвечает команда `mount`_._

Например, как было бы в _Windows_: если бы мы добавили ещё один жёсткий диск, его не нужно было бы отдельно размечать и добавлять новую букву, а можно было бы просто примонтировать в `C:\Пользователи`.

_Windows_ имеет диски и разделы, и диски именует похожим образом: по алфавиту, как и делит разделы, но в данном случае всё это от пользователя скрыто. Тогда как у _Linux_ весь исходный код является открытым и даже можно предлагать свои поправки, чтобы они вошли в официальную версию ядра, или просто править самому, создавая свою версию операционной системы.

В этом вводном юните вы ознакомились с короткой историей и поверхностной теорией. Дальше будет больше трудностей, но пугаться их не стоит.
# 1.2 Концепция Linux
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/a4ea250ed92fbc8ef70bf25ec2af13e7/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/php_m19_unit2_intro.png)

**Виртуальная машина** — это программа или комплекс программ, которые позволяют эмулировать работу физического компьютера.

По сути, при помощи виртуальных машин **на базе одного физического сервера** вы можете запустить **несколько виртуальных**.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/402210d2b693d5d2c27eb50b58de3491/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/php_m19_u1_pic.png)


Создавая виртуальную копию сервера, вы можете получить все требующиеся вам для конкретной задачи условия работы, которые будут приближены к условиям реального использования: та же операционная система, та же структура директорий, те же программы обслуживания.

При работе с виртуальными машинами мы выделяем каждой виртуальной машине свой лимит ресурсов, оставляя физической машине, которая обслуживает виртуальные, свой запас для контроля виртуальных машин. Таким образом, если виртуальная машина войдёт в состояние без ответа, вы сможете через физическую машину, которая никак от этого не пострадает, перезагрузить виртуалку и работать дальше. 

Также важно отметить, что с виртуальной машины очень легко снять копию для резерва. Практически все системы виртуализации поддерживают так называемые _Snapshots_, которые по сути фотографируют текущее состояние машины и позволяют развернуть копию по такому снимку. Разумеется, это не единственный способ восстановления — виртуальные машины можно записывать в образы, делать воспроизводимыми и т.п. Но об этом мы ещё поговорим далее в нашем курсе.

Виртуальные машины могут быть объединены в сеть, быть доступными друг для друга, но иметь каждая свой пул ресурсов. Разделение ПО по виртуальным машинам на реальных системах является нормой и залогом стабильной работы каждого компонента.

Теперь давайте обратимся к **основополагающим понятиям виртуализации**. 

> **Виртуальная машина** — это эмулируемый «виртуальный» компьютер, который имеет свои виртуальные устройства (_CPU, RAM,_ сетевые адаптеры и т.д), виртуальный жёсткий диск, где устанавливается своя независимая операционная система (гостевая). Несмотря на виртуальность оборудования, установленные приложения работают с ним, как с настоящим. Виртуальная машина изолирована от физической (хостовой) машины, но может иметь доступ к её диску и к другим устройствам (_USB,_ сеть) — это называется «проброс».

**Хост** — операционная система компьютера, на котором установлена виртуальная машина.

Диск виртуальной машины может быть фиксированным, когда на хостовой машине создаётся файл статического размера. Это наиболее быстрый способ работы. Также можно создать и динамически изменяемый диск виртуальной машины, если вы заранее не знаете, какой размер будут занимать файлы внутри виртуалки. Однако это более медленный тип хранения и доступа.

**Гипервизор** — процесс, отделяющий хост и виртуальную машину друг от друга, управляющий разделением ресурсов между запущенными виртуальными машинами.

---
Среди ПО, которое обеспечивает работу виртуальных машин, можно выделить множество систем:

*   _Virtualbox_ — наиболее доступное для быстрой и простой разработки средство виртуализации. Позволяет создавать виртуальные машины без особенного погружения в понимание механики их функционирования.
*   _OpenVZ_ — система, которая фактически не разграничивает виртуальные машины, но работает на уровне эмуляции вызовов ядра хостовой операционной системы.
*   _KVM_ — даёт наиболее полную изоляцию машин друг от друга, но является довольно сложной в понимании.
*   _Xen_ — требует, чтобы ядро хостовой ОС совпадало с ядром виртуальной ОС. То есть на машину с _Windows_ вы не установите _Linux_ виртуалку
*   _VMWare_ — проприетарное средство виртуализации.
---

Итого к плюсам виртуальных машин мы можем отнести:

*   гибкость,
*   отказоустойчивость,
*   изолированность,
*   воспроизводимость.

Однако любой уровень абстракции, отделяющий исполнимый код от железного оборудования, будет снижать быстродействие. К счастью, развитие современных виртуальных машин делает эту разницу пренебрежимо малой, особенно в свете плюсов виртуалок.  

Поскольку на одном компьютере могут работать несколько виртуальных машин, то отказ такого хостового компьютера может привести к потере всех виртуалок. Эта проблема решается за счёт **облачных систем**, где железные компьютеры объединяются в один виртуальный огромный сервер. И каждая виртуалка считает, что она работает на этом суперсервере. Если какой-то из серверов, образующих этот большой сервер, выходит из строя, виртуалка этого не замечает, а ПО облачной системы отвечает за то, чтобы переместить исполняемую виртуальную машину в другую зону суперкомпьютера.

Облачные системы представлены на рынке такими компаниями как:

*   Яндекс,
*   _Amazon_,
*   _Google_
*   и многими другими.

Во втором блоке нашего курса мы перейдём к работе на _Яндекс.Облако_ и будем работать уже с двумя виртуальными машинами.
# 1.3 Установка виртуальной машины
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/f6a9aa438279483d13694ca34e0e826f/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.3.svg)

## **Установка Linux сервера**

Для начала установки сервера нам нужно подготовиться и скачать определённые программы. Вы можете использовать любую виртуальную машину, а мы рассмотрим установку на примере _VMWare._

*   [VMWare player](https://download3.vmware.com/software/player/file/VMware-player-16.0.0-16894299.exe) — _VMWare workstation_ — это программа, которая позволяет создавать, запускать и управлять виртуальными машинами. Таким образом на одном компьютере можно создавать и запускать различные версии операционных систем.
*   [Ubuntu server](https://releases.ubuntu.com/20.04.1/ubuntu-20.04.1-live-server-amd64.iso) — _Ubuntu_ _20.04_ — это одна из версий операционной системы _Linux._
*   [Putty](https://www.putty.org/) — эмулятор терминала, который используется для удалённого подключения к другим системам (в нашем случае — к _Ubuntu_).

> Если какая-то из указанных ссылок не работает, попробуйте скачать программы с _Google_ Диска: [VMWare player](https://drive.google.com/file/d/1LXV8w7KlYU_cnzYgvIz0lJ3PkRFQ-WzH/view?usp=sharing), [Ubuntu server](https://drive.google.com/file/d/1Uy_vmFMx4T6IDZdDan3mcoWyYhoC0xQJ/view?usp=sharing), [Putty](https://drive.google.com/file/d/1P6ivBuBUQNluQhQwrSD3eHG6UPNHcmV-/view?usp=sharing).

Использование _Ubuntu_ и _Putty_ полностью бесплатно, а _VMWare player_ бесплатно в рамках некоммерческого использования. Все программы лучше **сохранять в одну папку**, для удобства установки по дальнейшему видеоуроку.

Ниже вы можете увидеть скринкаст по установке.

> **Обратите внимание!** Для успешного прохождения курса необходимы ОС _Windows_ или _Linux,_ установленные на оборудование, поддерживающее аппаратную виртуализацию, и ПО из выше перечисленных ссылок. Установка ПО из других источников из-за различия в версиях может повлиять на результаты выполнения заданий, и платформа засчитает эти результаты как неверные.

Для работы с виртуальными машинами необходима **поддержка аппаратной виртуализации**. Для разных материнских плат она включается по-разному. Как это сделать, вы можете посмотреть в инструкции к своей материнской плате или [по ссылке](https://vellisa.ru/enable-virtualization-computer) (для ОС _Windows_).

Информацию по установке виртуальной машины на _macOS_ можно найти [здесь](https://lumpics.ru/virtual-machines-for-mac-os/).

**Теперь немного про ssh**

**_SSH_** — это зашифрованный сетевой протокол, который предназначен для удалённого доступа к консоли ОС. В нашем случае на хостовой машине задан порт 22. Запустив терминальный клиент _PuTTy,_ вы соединились с виртуальной машиной.

>**Обратите внимание,** что по протоколу _SSH_ производится соединение практически со всеми  _Linux-_системами для управления и настройки.
Чтобы подключиться по _SSH,_ обязательно должна быть возможность соединения от хоста к ВМ . Это легче всего реализовать, используя _«Bridged»_ в качестве типа сетевого соединения в настройках ВМ.
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/0e28127f90c77b6adcc8b648c302e064/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/admin_m1_connection.png)

Выполнив установку и зайдя на свой сервер с помощью  _PuTTy,_ вы сразу попадаете в чёрное окно с белыми буквами. Это и есть наш текстовый сервер.

Большинство операций в _Unix_\-системах выполняются не с помощью графического интерфейса (_GUI_), к которому мы так привыкли в _Windows_, а с помощью командной строки (_CLI_), которая в _Unix_\-системах именуется терминалом.

![](https://lms-cdn.skillfactory.ru/assets/courseware/v1/d5ebacfaed1aa2791ed98391af52e1bb/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/dspr-u8-md1-1.png)

#### **Зачем нужна командная строка?**

Использование терминала вместо графического интерфейса начинающему пользователю _Linux_ может показаться излишне изощрённым способом взаимодействия с ОС. Но у этого подхода существует ряд неоспоримых преимуществ, которыми, конечно, пользуются системные администраторы:

1.  Скорость взаимодействия пользователя с ОС выше из-за отсутствия подтормаживания графического интерфейса.
2.  Скорость взаимодействия увеличивается по мере освоения основных команд терминала.
3.  Большинство команд терминала позволяет «лёгким движением руки» произвести сложную операцию над файлами и папками, например, найти и удалить в папке все текстовые файлы, в которых присутствует слово «привет».
4.  Использование командной строки для удалённого администрирования серверов сокращает интернет-трафик, поэтому администрировать сервера можно даже с мобильного телефона в сети _3G_.
5.  На серверах обычно нет графического интерфейса (_GUI_), поэтому взаимодействие с ними осуществляется через терминал.
6.  Командная строка (_CLI_) позволяет автоматизировать повторяющиеся действия.

На протяжении всего обучения мы будем работать с серверами, используя терминал. Задача первого блока по основам _Linux_ и администрированию _Linux_ на уровне пользователя как раз заключается в том, чтобы научить вас комфортно работать в терминале. Важно, чтобы со временем у вас не возникало трудностей с работой в терминале и большими текстовыми данными.

# 1.4 Manual
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/7ca71aa23cf23402be83be15f7ec5e33/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.4.svg)

Цель этого юнита — научиться работать со страницами мануалов. Это очень просто, если у вас есть минимальные основы технического английского или вы пользуетесь переводчиком.

Для более комфортного просмотра нажмите «Перейти в полноэкранный режим» в нижнем правом углу окна видео.

## **Что такое мануалы и зачем их читать**

Когда вы залогинитесь в системе, то вряд ли поймёте, что делать дальше, если никогда не работали с терминалом. Поэтому сначала стоит разобраться, как читать мануалы (от англ. _manual —_ руководство).

Почти каждая утилита или команда содержит подробный мануал. В интернете много описания к командам, но именно _встроенные мануалы_ имеют самое подробное описание. Оно сухо и не всегда однозначно, но мы подробно по нему пройдёмся. Это первое, что вы должны освоить. Потому что, если вдруг вам придётся столкнуться с незнакомой командой, то вы сразу сможете прочитать, что она делает. Чтение мануалов пригодится на любом этапе работы с этой операционной системой, будь вы новичок или опытный специалист.

Первая команда, которую потребуется освоить, — это  **`man`,** сокращённо от _manual_.

Команда позволяет выводить на экран справочные страницы к командам. Эти страницы предоставляются почти со всеми _\*nix_ дистрибутивами.

---
**Страницы разделены на категории:**
*   Основные команды.
*   Системные вызовы (функции, предоставляемые ядром _Linux)._
*   Библиотечные вызовы (функции стандартной библиотеки языка _С_).
*   Специальные файлы (обычно расположенные в **`/dev`**) и драйверы.
*   Форматы файлов и соглашения.
*   Игры.
*   Прочие страницы (включая соглашения).
*   Команды для системного администрирования (для которых обычно требуются права суперпользователя) и демоны.
---

Немного уточним про незнакомый термин — демон.

**Демон** (_daemon_) — это программа, запускаемая в _Linux_ в фоновом режиме системой, и работающая в фоновом режиме без взаимодействия с пользователем. Например, сетевые серверы, такие как сервер почты и пр. Более подробно будем их рассматривать в последующих модулях.

### **Man**

Для отображения `man` страницы (страницы мануала) используем команду формата:

`$ man имя_страницы`

Имя страницы, которое требуется ввести, соответствует команде _Linux._

Для примера попробуем вывести мануал к самой команде man. Введите такую команду:

`$ man man`

На выводе вы получите страницу вида:

```sh
MAN(1)                                                          Manual pager utils                                                                                                    

NAME
       man - an interface to the system reference manuals

SYNOPSIS
       man \[man options\] \[\[section\] page ...\] ...
       man -k \[apropos options\] regexp ...
       man -K \[man options\] \[section\] term ...
       man -f \[whatis options\] page ...
       man -l \[man options\] file ...
       man -w|-W \[man options\] page ...

DESCRIPTION
       man  is the system's manual pager.  Each page argument given to man is normally 
```

Это подробное описание самой команды. Перемещаться по ней можно клавишами _Вверх_, _Вниз_, _Пробел_, _Page up_, _Page down_ и многими другими. Более подробную информацию вы можете узнать в справке.

Для выхода требуется нажать `q`, для справки — `h`. При выборе справки (нажатии `h`) откроется подробная инструкция: какими клавишами или командами можно работать с этой страницей. Так как эта справка занимает больше ста строк, подробно рассматривать тут её не будем, рассмотрим структуру _man_\-страниц.

## **Разделы**

Для удобства навигации все _man_\-страницы соответствуют единому стандартному формату.

Вот **список основных разделов**, которые часто используются на страницах:

*   _NAME_ — имя команды и краткое однострочное описание её назначения.
*   _SYNOPSIS_ — список опций (ключей) и аргументов командной строки, которые принимает команда, либо параметры функции и её заголовочный файл.
*   _DESCRIPTION_ — более подробное описание назначения и принципов работы команды или функции.
*   _EXAMPLES_ — типовые примеры использования, обычно от самых простых к более сложным.
*   _OPTIONS_ — описания для каждой из опций, которые принимает команда.
*   _EXIT STATUS_ — коды возврата и их значения.
*   _FILES_ — связанные с командой или функцией файлы.
*   _BUGS_ — вероятные проблемы, связанные с работой команды или функции, и ожидающие решения. Также известны как _KNOWN BUGS_.
*   _SEE ALSO_ — список связанных команд и функций.
*   _AUTHOR, HISTORY, COPYRIGHT, LICENSE, WARRANTY_ — информация о программе: её история, условия использования, создатели программы.

В начале обучения потребуется заострить внимание на разделах _OPTIONS_ и _EXAMPLES_. В них подробно описываются ключи к командам и примеры использования.

Немного отойдём в сторону и рассмотрим, что значит слово «_ключи_». Условимся, что всё, что будет идти после команды, — это параметры.

Параметры делятся на два типа:

1.  Ключи.
2.  Аргументы.

**Ключи** — это то, перед чем ставится один или два знака минуса (`-`, `--`). Если в команде присутствуют ключи, то они всегда ставятся перед аргументами. У команды могут быть только ключи, только аргументы или, чаще всего, и то, и другое одновременно.

Обычно **аргумент** — это то, над чем выполняется команда. Чтобы не путаться в `man man`, возьмём примером утилиту `ip` и поработаем с ней.

`$ man ip`

`man` — это команда, а `ip` в данном случае является аргументом.

`$ man -f ip`

man — это команда, `-f` — это ключ, ip — это аргумент.

## **Ключи**

Ключи модифицируют работу программы, заставляя её использовать другие свои функции. У команд может быть множество ключей, и их можно и нужно комбинировать.

Общий способ использования команд выглядит следующим образом:  `<команда> <ключ> <аргумент>`, где:

*   команда (программа) — определяет необходимое действие (что делать);
*   ключи (опции) — как делать;
*   аргументы — с чем делать.

Работу с ключами рассмотрим далее по юнитам, а пока не будем на этом задерживаться.

Давайте рассмотрим эти разделы на примере. Введите команду:

`$ man man`

Экран терминала заполнит большое количество текста. Рассмотрим разделы, которые упростят жизнь в работе с _Linux._ 

Самая первая строка выглядит так:

```console
MAN     (       1       )Manual pager       utilsMAN        (       1       )
```

На _man_\-страницы ссылаются по имени с указанием категории в скобках. Это связано с тем, что иногда существует сразу несколько _man_\-страниц с одинаковыми именами, но в разных категориях. И в некоторых случаях команде `man` передаётся номер категории перед аргументом.

Нажмите `q`, чтобы выйти с _man_\-страницы, и введите:

`$ man 7 man`

Как видите, появляется совершенно другая информация.

Нажмите q, и вернёмся к `man man`.

Далее идёт `NAME`:

```sh
NAME
       man - an interface to the system reference manuals
```

Как понятно из контекста, это название и краткое описание команды.

Далее идёт _SYNOPSIS._ Как было описано выше, он отвечает за список ключей и аргументов, которые принимает команда.
```sh
SYNOPSIS
       man \[man options\] \[\[section\] page ...\] ...
       man \-k \[apropos options\] regexp ...
       man \-K \[man options\] \[section\] term ...
       man \-f \[whatis options\] page ...
       man \-l \[man options\] file ...
       man \-w|\-W \[man options\] page ...
```
После идёт _DESCRIPTION,_ где команда описывается более развёрнуто.
```
DESCRIPTION
       man  is the system's manual pager.  Each page argument given to man is normally the name of a program, utility or function.
...
```
В _EXAMPLES_ описаны примеры с пояснениями, как можно использовать команду:
```
EXAMPLES
       man ls
           Display the manual page for the item (program) ls.
...
```
Нажмите стрелку _Вниз_ или «_J_», пролистайте файл ниже. _OVERVIEW_ и _DEFAULTS_ нам сейчас не нужны, поэтому сразу перейдём к _OPTIONS_.

В _OPTIONS_ приведены все ключи, которые можно использовать к данной команде.
```
OPTIONS
       Non\-argument options that are duplicated either on the command line, in $MANOPT, or both, are not harmful.  For options that require an argument, each duplication will override the previous argument value.

   General options
       \-C file, \--config-file=file
              Use this user configuration file rather than the default of ~/.manpath.

...
```
Из _OPTIONS_ к `man` видно, что существует ключ `-k`, про который ниже по странице можно прочитать подробнее:
```
  Main modes of operation
       -f, \--whatis
              Equivalent to whatis.  Display a short description from the manual page, if available.  See whatis(1) for details.

       -k, \--apropos
              Equivalent to apropos.  Search the short manual page descriptions for keywords and display any matches.  See apropos(1) for details.
```
Здесь коротко описано, что делает ключ, также описан однобуквенный ключ \-k, который используется совместно с символом `-`, а также полный ключ `--apropos`. Полные ключи используются совместно с `--`.

Попробуем использовать команду man с ключом \-k. Как описано в мануале (см. выше, английский — это важно), этот ключ используется для поиска подходящих _man_\-страниц по значению, т. е. это поиск _man_\-страниц по ключевому слову.

Например, при использовании с коротким ключом:

`$ man -k file`

или при полном ключе:

`$ man \--apropos file`

Данная команда выдаст все _man-_страницы, в которых есть упоминания работы с файлами или файловыми системами.

Вместо того чтобы отображать _man_\-страницу целиком, вы можете вывести лишь её краткое описание, используя команду `whatis`.

Например:

`$ whatis ls`

Также эту команду можно заменить командой `man` с ключами:

`$ man -f ls`

или

`$ man --whatis ls`

Команды будут иметь один результат.

Т.е. ключ `-f`, как и `--whatis`, отвечает за краткую справку, для чего именно предназначена команда.

## **Подведём итог**

Начало положено, и вы освоили первую команду, которая станет вашим спасательным кругом на протяжении всей вашей работы с операционной системой _Linux_ — будете вы начинающим специалистом в этой сфере или уже _Senior Linux System Administrator_! На кирпиче, заложенном в самом начале строительства, в дальнейшем будет держаться вся стена.

**В этом юните вы ознакомились:**

*   c командой `man` и использованием страницы мануалов;
*   с ключами к командам, какие они бывают и как их использовать.

В завершение этого юнита мы предлагаем вам полистать мануалы к командам, которые будем изучать в дальнейших юнитах: `mkdir`, `rmdir`, `cd`, `ls`.

# 1.5. Директории
![](https://lms-cdn.skillfactory.ru/assets/courseware/v1/6edcc9c1a102d840f8356982b704151e/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/1.5.pic.jpg)

В этом юните будет рассказано об одной из основ любой операционной системы — работе с директориями. Вы узнаете, как создавать, удалять, перемещаться по директориям.

Умение оперировать директориями — это важный пласт в понимании _Linux_.

Когда вы проходите авторизацию в системе, то сначала попадаете в свою домашнюю папку, которая называется по вашему логину в системе. Все домашние папки пользователей располагаются в директории `/home`. Так принято во всех \*_nix_ системах.

В _Linux_ система папок древовидная. И соответственно взаимосвязанная, то есть у нас есть корневая директория `/`. Из неё «растут» другие папки `/home`, `/bin`, `/etc` и так далее. Каждый новый уровень вложенности (выше по стволу) отделяется от предыдущего слешем `/`.  
`/home/user/program/configs/` является папкой 5-ого (!) уровня вложенности.

<table>
<tr style="height: fit-content; background-color: #00b43f; color: #ffffff; font-weight: bold;">
<td>Уровень</td>
<td>Пример</td>
</tr>
<tr>
<td>1-й уровень</td>
<td>/</code> (root, корень)</td>
</tr>
<tr>
<td>2-й уровень</td>
<td>/home/</code></td>
</tr>
<tr>
<td>3-й уровень</td>
<td>/home/user</code></td>
</tr>
<tr>
<td>4-й уровень</td>
<td>/home/user/program</code></td>
</tr>
<tr>
<td>5-й уровень</td>
<td>/home/user/program/configs/</code></td>
</tr>
</table>

Ярлык для домашней директории `~/` означает почти всегда 3-й уровень `/home/user/`. Работая с ярлыком, вы фактически работаете с папкой `/home/user/`, соответственно, когда вам нужно создать папку в домашней директории, вы можете написать `mkdir /home/user/test_directory/` или `mkdir ~/test_directory/`. То есть вы просто используете более короткую форму записи для `/home/user/`.

И так же, когда вы не указываете никакой путь для `cd` или, например, `mkdir`, вы просто работаете с папками на уровне относительно вашего текущего местоположения. Получается, что находясь в домашней папке, вы можете сделать `mkdir test_directory`, и для терминала это будет эквивалентно `mkdir /home/user/test_directory` или `mkdir ~/test_directory`. Но если вы находитесь в другой папке, например `/home/`, и вы сделаете `mkdir test_directory`, терминал попытается создать её в `/home/`. В то же время, если находясь где угодно в файловой системе, вы сделаете `mkdir ~/test_directory`, терминал её создаст строго в домашней директории, потому что для него это будет равно указанию абсолютного пути, команде `mkdir /home/user/test_directory`.

### **cd**

Для перехода из директории в директорию используется команда `cd` (от англ. _change directory_).

Синтаксис команды такой:

`$ cd ключи папка назначения`

Ключей для команды всего три, но о них мы поговорим позже. Когда будем проходить тему символьных ссылок, тогда и вспомним про эти ключи.

Стандартно в системе существуют несколько основных директорий. Поговорим немного о директориях и о том, какие типы данных в них хранятся.

Условно их можно поделить на несколько типов:

1. **Директории для хранения данных**

Это директории, где пользователи могут хранить персональные данные `/home/имя_пользователя`, которые не должны быть доступны другим пользователям, а также общие данные, например, `/media` и директория для монтирования `/mnt`.

2. **Директория для изменяемых данных**

Сюда входят директория `/var` и вложенные в неё директории, такие как `/log`  для хранения файлов логов, директория `/cache` для хранения кешированных данных приложений, `/spool` для файлов очередей (например, печати и почтовых сообщений), `/lib` для хранения файлов с данными состояния приложений.

3. **Директории для хранения файлов конфигурации**

Это в первую очередь директория `/etc`, где будут храниться все файлы конфигураций для серверов и прочих приложений. В этой же директории находятся вложенные директории `/init.d` или `/systemd` в зависимости от версии _Linux,_ в которых хранятся сценарии для запуска, остановки, перезагрузки, статуса демонов и пр.

4. **Директории для хранения бинарных файлов**

Это директории `/bin` и `/sbin`, в них содержатся бинарные файлы, которые могут применяться всеми пользователями или только суперпользователями (суперпользователь — это специальный аккаунт, имеющий права на выполнение абсолютно любых операций, т.е. никак не ограничен правами). Для того чтобы было понятней, утилита `mkdir`, отвечающая за команду с таким же названием, хранится в `/bin/mkdir`. И когда вы её запускаете в командной строке, то обращение идёт именно в эту директорию. Также к этому типу директорий относится `/lib`, где хранятся библиотеки для бинарных файлов из `/bin` и `/sbin`, а также директория `/opt`, которая используется для хранения вспомогательного программного обеспечения.

5. **Директории для системных ресурсов**

Это в первую очередь директория `/usr`. Сокращение обозначает не пользователя _(user),_ а _Unix System Resorces_, то есть системные ресурсы. В неё вложена директория `/src`, которая отвечает за хранение файлов исходного кода ядра. Директория `/share` ответственна за хранение независимых от архитектуры данных. Например, в ней хранится директория `/man`, отвечающая за страницы мануалов. Также в `/usr` есть вложенная директория `/local`, которая может использоваться для локальной установки ПО системным администратором.

6. **Директории в оперативной памяти**

Это директория `/dev`, сокращение от _devices._ В ней хранятся файлы, которые образуются в процессе определения устройств свойствами ядра. Это могут быть и _usb-_устройства, и жёсткие диски, и вообще всё, что подключается к серверу. Директория `/proc` является другой специальной директорией, где находятся файлы представления ядра ОС. На данном этапе конкретное назначение этой директории объяснить не представляется возможным, просто знайте, что она есть. Мы обратимся к ней подробнее ближе к концу курса.

Это основные директории, с которыми вы будете часто иметь дело, но существует ещё много директорий. Пусть это вас не пугает, сейчас не будет требоваться запомнить их все наизусть. Знания и понимание будут открываться по мере обучения.

Директория, где вы находитесь, описывается слева, то есть, если вы выполните команду:

```sh
$ cd /var
```

...то будете перемещены в директорию `/var`. Это будет отображено в командной строке.

```sh
$ user@local:/var$
```

`user` — это имя пользователя, под которым вы работаете.

`local` — локальное имя машины, на которой вы работаете.

`:/var` — показывает, в какой директории вы находитесь.

Также можно определить местонахождение с помощью команды `pwd`:
```sh
$ user@local:/var$ pwd
/var
```
Вернуться в свою домашнюю директорию можно по полному пути:
```sh
$ cd /home/user
```
Либо:
```sh
$ cd ~/
```
`~` — это «ярлык» для домашней директории. Это тильда, и обычно она живёт на одной клавише с «Ё», если у вас русифицированная клавиатура.

Для перемещения в директорию на уровень выше используется ярлык _(shortcut)_ `../`.
```sh
$ cd ../
```
Попробуйте самостоятельно походить по директориям.

### **mkdir**

Когда вы вернулись в домашнюю директорию (проверьте себя командой `pwd`), попробуйте создать внутри неё свою директорию.

Директории создаются командой `mkdir` — сокращённо от _**m**a**k**e **dir**ectory_:
```sh
$ mkdir testdir
```
При использовании этой команды создаётся директория там, где вы находитесь. В данном случае в вашем домашнем каталоге.

Можно также создавать директории по абсолютному пути:

$ mkdir /home/user/tesrdir

Эти способы аналогичны, но вторым способом можно создавать директории из любого местоположения в системе.

Чтобы создать несколько директорий, надо перечислить несколько имён через пробел:

$ mkdir testdir1 testdir2 testdir3

### **rmdir**

Для удаления пустых директорий используется команда `rmdir` — сокращение от _**r**e**m**ove **dir**ectory_.
```sh
$ rmdir /home/user/tesrdir
```
Если директории не пустые, то команда rmdir не сработает. Для удаления не пустых директорий используется команда `rm` с определёнными ключами. С ней познакомимся в следующем юните.

## **Подведём итог**

В этом юните вы узнали, как создавать папки. Если в _Windows_ обычный пользователь это делает за пару кликов мышкой, то тут это может вызвать некоторые затруднения. Но дорога рождается под ногами идущего.

Директории — это одна из фундаментальных основ. Без них не будут нормально функционировать сайты, пользователи не смогут подключаться к серверу по протоколу _FTP,_ логам будет негде храниться, и порядка не будет.

В этом юните было расписано, как работать с директориями, вы узнали про три команды для работы с ними. Но на этом работа с директориями не закончена, и в дальнейших модулях с ними ещё не раз придётся столкнуться.

# 1.6 Чтение файлов
## **Команды для чтения файлов**

Один из самых важных навыков при работе с текстовыми операционными системами — это чтение файлов. Подавляющее большинство файлов, с которыми придётся работать, хранятся в текстовом виде.

Для чтения используются команды:

*   `cat`,
*   `head`,
*   `tail`,
*   `less`.

Рассмотрим каждую из них подробней и с примерами.

### **cat**

`cat` (сокращение от _concatenate) —_ команда (утилита), выводящая данные файла или последовательно несколько файлов, объединяя их в поток.

Примеры использования:

*   когда требуется просмотреть какой-либо файл;
*   вывести файл без изменения;
*   когда требуется объединить несколько файлов.

Основные ключи для работы с командой:

`-n`, `--number` — выводит номера строк.

`-b`, `--number-nonblank` — выводит строки с номерами, кроме пустых. Отменяет предыдущий ключ.

Остальные команды используются реже, про них отдельно можно прочитать в _man cat_.

Примеры использования:
```sh
$ cat text\_file
```
Попробуем применить команду на деле. Перейдите в директорию, где хранятся логи:
```sh
$ cd /var/log
```
И откроем файл `dmesg`:
```sh
$ cat dmesg
```
Команда выводит все строки из файла, но в данном случае, т. к. файл большой, он займёт весь экран и выше. Вы увидите примерно такое:
```sh
\[    7.043906\] systemd\[1\]: Mounted FUSE Control File System.
\[    7.059486\] systemd\[1\]: Mounted Kernel Configuration File System.
\[    7.067044\] systemd\[1\]: Finished Load/Save Random Seed.
\[    7.090558\] systemd\[1\]: Finished Create System Users.
\[    7.092262\] systemd\[1\]: Starting Create Static Device Nodes in /dev...
\[    7.108464\] systemd\[1\]: Finished Apply Kernel Variables.
\[    7.118327\] systemd\[1\]: Finished Set the console keyboard layout.
\[    7.142019\] systemd\[1\]: Finished Create Static Device Nodes in /dev.
\[    7.143687\] systemd\[1\]: Starting udev Kernel Device Manager...
```
Выведите все строки с номерами:
```sh
$ cat -n dmesg
```
Вы заметите, что слева появится нумерация строк:
```sh
  1307  \[    7.043906\] systemd\[1\]: Mounted FUSE Control File System.
  1308  \[    7.059486\] systemd\[1\]: Mounted Kernel Configuration File System.
  1309  \[    7.067044\] systemd\[1\]: Finished Load/Save Random Seed.
  1310  \[    7.090558\] systemd\[1\]: Finished Create System Users.
  1311  \[    7.092262\] systemd\[1\]: Starting Create Static Device Nodes in /dev...
  1312  \[    7.108464\] systemd\[1\]: Finished Apply Kernel Variables.
  1313  \[    7.118327\] systemd\[1\]: Finished Set the console keyboard layout.
  1314  \[    7.142019\] systemd\[1\]: Finished Create Static Device Nodes in /dev.
  1315  \[    7.143687\] systemd\[1\]: Starting udev Kernel Device Manager...
```
Ключ `-b` выводит только непустые строки и их номера, то есть, если строка пустая, то она будет пропущена по нумерации.
```sh
$ cat -b dmesg
```
Можно вывести последовательно несколько файлов:
```sh
$ cat  dmesg syslog auth.log
```
Выше упоминалось, что они выводятся потоком, значит, их вывод можно куда-либо перенаправить. При отсутствии каких-либо условий вывод выходит на экран терминала. Для перенаправления вывода используются операторы `>` и `>>`.

Например, можно перенаправить вывод из двух файлов (из примера выше) не на терминал, а в какой-то другой файл.
```sh
$ cat   dmesg syslog auth.log > ~/text\_file
```
И если проверить `text_file`, то будет видно, что он заполнился последовательным выводом из этих двух файлов.

Оператор \> полностью заменяет данные в файле информацией.

Оператор \>> добавляет информацию в конец файла, не удаляя предыдущие данные.

### **head**

_head_ выводит первые строки с начала файла. Удобна в том случае, если в файле содержится много строк, но надо вывести только первые. По умолчанию данная команда выводит первые 10 строк. Ключи для работы с командой:

`-n`, `--lines`  — выводит строки, начиная от первой до той, которая указана после `-n`.

`-c`, `--bytes` — выводит данные побайтно, начиная с первого и заканчивая указанным после `-c`.

Примеры работы:
```sh
$ head ~/text\_file
```
Выведет первые 10 строк.
```sh
$ head -n 5 ~/text\_file
```
Выведет первые 5 строк.
```sh
$ head -с 5 ~/text\_file
```
Выведет первые 5 байт из файла.

### **tail**

`tail` — утилита, работающая аналогично утилите `head`, но только с конца файла. Используются аналогичные ключи `-n` и `-c`, но дополнительно используется ключ `-f`, который выводит новые строки с конца в режиме реального времени. Эта функция может использоваться при парсинге логов.

Например, когда вам нужно смотреть, какие строки записываются в файл логов в режиме онлайн, когда идёт отладка какого-либо сервера, а информацию требуется получать постоянно.

### **less**

`less` — команда для построчного чтения текста. В отличие от `cat`, не выводит на экран все данные, а хранит их в буфере, позволяя пролистывать страницы вперёд и назад. Навигация осуществляется с помощью стрелок на клавиатуре.

Также в нём участвуют такие команды:

`h` — вызов справки,

`q` — выход,

`SPACE` — на экран вперёд,

`b` — пролистать экран назад,

`k` и `j` или стрелки вверх и вниз — вертикальная прокрутка по строке,

`g` — перейти на первую строку,

`<N>g` — перейти на строку _N_,

`G` — перейти на последнюю строку,

`F` — перейти на последнюю строку файла и ожидать записи новых строк (аналог `tail -f`, не работает со стандартным вводом),

`/pattern` — поиск по шаблону вперёд (вниз по странице),

`?pattern` — поиск по шаблону назад (вверх по странице),

`n` — следующее совпадение,

`N` — предыдущее совпадение,

`mбуква` (`m` и `буква`) — отметить позицию буквой, т.е. оставить закладку на определённом моменте текста,

`'буква` (апостроф и буква) — перейти на отмеченную позицию, которая была создана предыдущей командой.

## **Подведём итог**

Путь _Linux_ тернист и далёк.

Когда-то давным-давно, когда копия ресурса _bash.org_ появилась в русскоязычном сегменте сети Интернет, там была шутка о том, что _Linux_ на самом деле дружелюбен, просто разборчив в друзьях.

Весь этот юнит посвящён просто чтению файлов, но в разных условиях надо использовать разные команды, а к ним ещё существуют и определённые ключи. Однако, просто освоив 4 утилиты — `cat`, `head`, `tail` и `less` — вы уже сделали большой шаг в мир текстовых операционных систем.

# 1.7 Редактирование файлов
## **Редакторы текста**

Так как операционная система работает в текстовом интерфейсе, все файлы редактируются с помощью редактора. В этом юните вы узнаете больше о редакторах текста.

Редактировать файлы вы будете всегда и много: файлы конфигураций, скрипты, настройки и т. д.

В _Windows_ встроенным редактором является блокнот (_Notepad_). Для _Linux_ же существует несколько текстовых редакторов, основные — это редактор **vi** и **nano**. В данном юните мы поговорим подробно про редактор _vi._ Он не интуитивен и не похож на другие текстовые редакторы, но именно он присутствует на всех _\*nix_ системах, и его не потребуется устанавливать дополнительно.

Если рассматривать краткую историю _vi_, то первую версию написал Билл Джоем в 1976 году. До него в ходу у тех, кто развивал _IT_ профессионально, был редактор _ed_, но он был слишком сложным для «простых смертных». Позже был разработан более доступный редактор _em_ (_editor for mortals_). Потом его модифицировали, назвав _en,_ а в дальнейшем на этой основе создали редактор _ex,_ в котором был визуальный режим, и вызывался он как раз командой _vi._

Так как всем было удобнее работать в визуальном режиме, создали новую версию редактора — _ex2.0_, который сразу запускался в визуальном интерфейсе. Версия редактора _ex 2.0_ получила сокращённое название _vi_, и вскоре стала самостоятельным редактором.

Изначально редактор писался для работы с клавиатуры в терминале _ADM-3A_ (см. изображение ниже). Как видно, на ней крайне ограниченное количество клавиш, нет выделенных стрелок и прочих привычных нам кнопок. И именно из-за этого в _vi_ такой непривычный пользовательский интерфейс.

![img](https://habrastorage.org/webt/59/d3/67/59d367418ed68012766700.jpeg)

Источник: [habrastorage.org](https://habrastorage.org/webt/59/d3/67/59d367418ed68012766700.jpeg)

## **vi**

Чтобы запустить редактор, используется команда `vi`.
```sh
$ vi filename
```
Работает сам редактор нестандартно из-за того, как говорилось выше, что имел ограниченную клавиатуру.

Для перемещения между символами и строками можно использовать стрелки на клавиатуре или буквенную клавиатуру: **_h_** — влево, **_l_** — вправо, **_j_** — вниз и **_k_** — вверх. Чтобы вызвать справку по _vi_, надо ввести `:h`. Именно через `:`. Потому что _vi_ имеет два режима: командный режим и режим ввода текста, и эта команда для первого режима.

Попробуйте создать новый файл в домашней директории с помощью команды, где `test_file` — имя файла, который надо создать или отредактировать.
```sh
$ vi test\_file
```
Вы увидите примерно такое:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/d4f0d134da07a0ade1a9bfdc243f911f/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.2.png)

Мигающий зелёным — это курсор. При вводе любого нового символа, символ будет появляться слева от него, а сам курсор — двигаться правее. Символы «**_~_**» означают отсутствие каких-либо строк, т. е. то, что мы находимся в самом конце файла.

Чтобы начать ввод, нажмите кнопку **_i_**, после этого редактор перейдёт в режим ввода текста. В левом нижнем углу должно появиться сообщение о том, что ввод разрешён.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/34472ef9145482fa2617c0e483b0c177/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.3.png)

Теперь вы можете ввести какой-либо текст.

Например, попробуем ввести текст и потренируемся на нём с командами.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/87993973d1998d1434af5dbdf845dfe6/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.4.png)

Но можно вводить любое количество строк, после каждой нажимая **_Enter_**.

В режиме ввода текста, когда горит _insert_, работают стрелки для перехода между символами, клавиша **_Backspace_** для удаления символа, _**Space**_ (пробел) для пробела.

Выйти из режима ввода текста можно клавишей **_Escape_**_._

Помимо **_i_**, есть ещё несколько способов редактирования текста.

Например, чтобы начать вводить текст со следующей строки, используется команда **_o_**.

При нажатии курсор сразу перепрыгивает на следующую строку. Не забывайте после ввода нажать **_Escape__,_** чтобы перейти в командный режим.

## **Команды vi**

Удаление текста можно осуществлять с помощью клавиши _**Delete**_ или с помощью _**x**_. Для этого вы выделяете курсором символ, который нужно удалить, нажимаете _Delete_ или _x_, и удаляется именно тот символ, который был выделен курсором.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/0eb1a90d700eaf2e1f9a31da18107039/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.5.png)

И после нажатия _x_:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/0029cf9cd6103ebbca3c86516513083f/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.6.png)

Для удаления строки нужно в командном режиме навести курсор на нужную строку и нажать **_dd_** (просто нажать два раза на клавишу **_d_**, без ввода `:`).

Для удаления слова надо навести курсор на первый символ слова и набрать **_dw_.** Вообще, если быть точнее, команда **_dw_** удаляет все символы, начиная с курсора и до пробела перед следующим словом.

Если навести курсор на _e_ в слове _test,_ и набрать **_dw_**,

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/080a4b1685e9e9a628cd9154d193d437/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.7.png)

то получится:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/e9e8a3ffe7d593224826eab94c4ec84e/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.8.png)

Можно редактировать и с помощью **_R_**. Действия этой команды похожи на действия _**i**_, но отличие в том, что новый текст не вставляется, а затирает старый.

Рассмотрим на практике. Наведите курсор на _f_ в слове _file:_

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/0accf991f2e961db8530c6b2a1fad464/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.9.png)

Нажмите **_R_** в командном режиме и введите слово _example:_

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/d8749245e6e009373e6410d1e5cc1603/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.10.png)

При этом, если в режиме ввода сотрёте набранный текст _example_ клавишей **_Backspace,_** то вернётся старый текст:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/19eee0f878484d51a7847b0bbb612836/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_1.7.11.png)

Если вдруг удалили что-то, что не требовалось, то, чтобы вернуться на один шаг назад, используйте клавишу **_u_** в режиме команд.

Выше упоминалось, как двигаться по тексту с помощью стрелок и буквенных клавиш, но для удобства существуют ещё команды.

Например, для перехода в начало следующего слова используется команда **_w_**, а команда **_b_** перемещает курсор на начало предыдущего слова.

Клавиши **_Home_** и _**End**,_ которые располагаются на дополнительной клавиатуре, перемещают курсор в начало строки и в конец соответственно. Аналогично с ними работают клавиши **_0_** и **_$_**.

Если файл большой и вмещает много строк, то можно листать его командами **_Ctrl-f_** вниз и **_Ctrl-b_** вверх.

Для перемещения курсора в конец файла используется **_G_**.

Также эта команда поможет переместиться на нужную строку. Например, чтобы переместиться на десятую строку, используется синтаксис **_10G._** Команда же **_1G_** перенесёт вас на первую строку, в начало файла.

Для сохранения текста используется команда **_:w_** (сокращённо от _write)._

> **Важно!** Сначала в данном случае вы вводите двоеточие (**:**), а за ним уже команды выхода или сохранения. После того как вы ввели двоеточие, курсор переместится на последнюю строку и будет работать в режиме одной строки.

Для выхода из редактора — команда _**:q**_ (сокращение от _quit)._

Эти команды можно объединить, чтобы одновременно выйти и записать **_:wq_**.

Если попытаетесь выйти из изменённого файла без сохранения, то он выдаст ошибку. Поэтому, чтобы выйти без сохранения, нужно использовать команду _**:q!**_.

Все эти команды должны вводиться в командном режиме, и они пишутся в левом нижнем углу. После ввода команды требуется нажать **_Enter._**

Команда **_ZZ_** аналогична **_:wq_**, и с помощью неё также можно выйти из редактора, сохранив документ.

Всегда можно обратиться к мануалу, введя в редакторе в командном режиме **_:help_** или **_:h_**.

Вот основной список команд, который надо запомнить и который пригодится:

<table>
<tbody>
<tr style="height: fit-content; background-color: #00b43f; color: #ffffff; font-weight: bold;">
<td>Команда</td>
<td>Описание</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>/str</em></strong></td>
<td style="text-align: left;">Поиск строки str вперёд. str может быть регулярным выражением</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>?str</em></strong></td>
<td style="text-align: left;">Поиск строки str назад</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>n</em></strong></td>
<td style="text-align: left;">Повторить поиск в том же направлении</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>N</em></strong></td>
<td style="text-align: left;">Повторить поиск в обратном направлении</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:e!</em></strong></td>
<td style="text-align: left;">Перезагрузить текущий файл</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:33</em></strong></td>
<td style="text-align: left;">Переместиться на 33-ю строку текстового файла</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>i</em></strong></td>
<td style="text-align: left;">Перейти в режим редактирования</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>a</em></strong></td>
<td style="text-align: left;">Перейти в режим редактирования после текущего символа</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>u</em></strong></td>
<td style="text-align: left;">Отменить последнее действие</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>.</em></strong></td>
<td style="text-align: left;">Повторить последнее действие</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>x</em></strong></td>
<td style="text-align: left;">Вырезать символ под курсором</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>yy</em></strong></td>
<td style="text-align: left;">Копировать строку</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>dd</em></strong></td>
<td style="text-align: left;">Вырезать строку</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>p</em></strong></td>
<td style="text-align: left;">Вставить</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>J</em></strong></td>
<td style="text-align: left;">Склеить две строки</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:w</em></strong></td>
<td style="text-align: left;">Сохранить файл на диске</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:wq</em> </strong>или <strong><em>ZZ &nbsp;</em></strong></td>
<td style="text-align: left;">Выход с сохранением файла</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:q</em></strong></td>
<td style="text-align: left;">Выход&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:q!</em></strong> или <strong><em>ZQ &nbsp;</em></strong></td>
<td style="text-align: left;">Выход&nbsp;без сохранением файла</td>
</tr>
<tr>
<td style="text-align: center;"><strong><em>:r</em></strong></td>
<td style="text-align: left;">Вставить в документ другой файл</td>
</tr>
</tbody>
</table>

## **Nano**

Синтаксис команды запуска редактора:
```sh
$ nano filename
```
Редактор _nano_ является более простым в освоении, чем _vi._ Принцип его работы похож на обычный блокнот _Windows._ Отличаются только горячие клавиши, но они все описаны на нижней строке открытого редактора.

Но на всякий случай основные будут перечислены тут:

*   **_Сtrl+x_** — выход.  
    Если предварительно файл был изменён, он предложит его сохранить. Для этого надо будет согласиться (откроется поле для ввода, он предложит ввести _y — yes_, _n — no_ или _с — cancel_), а потом предложит изменить имя файла или оставить его таким же.
*   **_Ctrl+o_** — сохранение файла.  
    Также предложит ввести новое имя для сохранения или оставить старое. Если вводить новое имя, то будет создан новый файл в той же директории, где происходило редактирование.
*   _**Ctrl+k**_ — вырезать текст.  
    Вырезает построчно.
*   **_Ctrl+u_** — вставить вырезанный текст.

## **Подведём итог**

В данном юните мы ознакомились с работой текстового редактора _vi_.

Как везде уже упоминалось, вы будете в первую очередь иметь дело с текстовой операционной системой, и редакторы являются неотъемлемой частью работы. _Vi_ непривычен и сложен, но после некоторой практики он будет казаться проще и удобнее, чем какие-либо другие текстовые редакторы.

Также советуем сделать упор на _vi_ и потому, что можете столкнуться с ситуацией, когда надо что-то изменить на сервере, а там только этот текстовый редактор, а ещё на сервере нет доступа в интернет, и нет возможности установить какой-либо другой. Да и если вас попросят на собеседовании показать, что вы умеете, и вы откроете _vi,_ это даст вам дополнительные баллы.

# 1.8 Элементарная работа с файлами
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/5512b66dc7b0486a5c30b1bfe6716fa9/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.8.svg)

В прошлых юнитах мы разбирались в директориях и редактировании файлов. В этом юните поговорим о том, как копировать, перемещать, переименовывать и удалять файлы.

## **Команда cp**

Для копирования файлов используется команда `cp` (сокращение от англ. _copy)._

Синтаксис команды простой:
```sh
$ cp \[ключи\] исходный\_файл конечный\_файл
```
или
```sh
$ cp \[ключи\] исходный\_файл конечный\_каталог
```
или
```sh
$ cp \[ключи\] исходный\_каталог конечный\_каталог
```
Рассмотрим ключи к команде на примерах.

`-R`, `-r`, `--recursive` копирует рекурсивно, т. е. все файлы и поддиректории в директориях.

Есть директория `/var/log`. В ней — файлы логов, а есть также вложенные директории с файлами логов. И для того, чтобы перекопировать все файлы и вложенные директории в папку `/home/user`, требуются эти ключи.
```sh
$ cp -r /var/log /home/user
```
*   `-i`, `--interactive` — запрашивает, требуется ли переписывать файл, если имя исходного совпадает с существующим конечным файлом. Для согласия нужно ввести _y_. Ввод любого другого символа с клавиатуры отменяет копирование.
*   `-n`, `--no-clobber` — отменяет копирование, если конечный файл уже существует. Используется в том случае, если вы копируете много файлов, но не хотите потерять какие-то аналогичные, которые уже есть в конечной директории.
*   `-u`, `--update` — скопирует файл, если только он был изменён в отличие от конечного. Если конечный файл более свежий, чем копируемый, то операция не произойдёт.
*   `-p` — сохраняет владельца, группы, флаги и временные метки при копировании. Если вы будете копировать без этого ключа, то новый файл будет создан от имени вашего пользователя.
*   `-f`, `--force` — если существующий конечный файл не может быть открыт для копирования, то удалит его и запишет новый.
*   `--remove-destination` — в отличие от \-f, сразу удалит существующий конечный файл без попытки его открыть и создаст новый.

## **rm**

Удаляются файлы с помощью команды `rm` (сокращение от _remove)._

С ней надо работать очень осторожно, т. к. _Linux_ не спрашивает, стоит ли удалять файлы, а просто удаляет без вопросов и каких-либо предупреждений. Также с помощью этой команды удаляются и непустые директории.

Синтаксис у команды:
```sh
$ rm \[ключи\] файл
```
или
```sh
$ rm \[ключи\] директория
```
Перечислим используемые ключи:

*   `-f`, `--force` — игнорируются несуществующие файлы и аргументы. Не выдаёт запрос на подтверждение удаления.
*   `-i` — выводит запрос на удаление каждого файла.
*   `-d`, `--dir` — удаляет пустую директорию.
*   `-r`, `-R`, `--recursive` — удаляет директории и содержимое в них.

Чтобы удалить файл с помощью команды rm, введите команду:
```sh
$ rm test\_file
```
Для удаления нескольких файлов их можно перечислить через пробел:
```sh
$ rm test\_file1 test\_file2 test\_file3
```
Чтобы удалить все файлы в директории, можно использовать символ `*`:
```sh
$ rm /dir/\*
```
Для удаления файлов вместе с директориями можно использовать:
```sh
$ rm -rf /dir/
```
Команду `rm` с ключами `-rf` требуется использовать очень осторожно.

Раньше с помощью команды `rm -rf` можно было удалить корневую систему с `/`. Сейчас по умолчанию к rm всегда ставится ключ `--preserve-root`, который не позволяет удалять корневой раздел `/`. Чтобы его удалить, требуется ключ `--no-preserve-root`. Не делайте этого.

Командой `rf` надо пользоваться с осторожностью, т. к. в _Linux_ нет такого аналога корзины как в _Windows,_ данные сразу будут удалены и восстановить их будет маловероятно. Если вы не уверены, стоит ли удалять файлы, лучше для начала перенесите их в другое место.

## **mv**

Файлы переносятся с помощью команды `mv` (сокращение от _move)._

Синтаксис такой:
```sh
$ mv \[ключи\] исходный\_файл конечный\_каталог
```
С помощью mv можно не только переносить файлы и директории, но и переименовывать их.

Рассмотрим на примерах.

Если вы хотите перенести файл из одной директории в другую, при этом вы находитесь в той же директории, в которой располагается файл, и перенести его, например, в директорию `/tmp/`, следует использовать синтаксис:
```sh
$ mv test\_file /tmp/
```
Основные ключи, которые используются с этой командой:

*   `-f`, `--force` — не спрашивать разрешения на перезапись.
*   `-i`, `--interactive` — спрашивать разрешения на перезапись существующих файлов.
*   `--` — ключ, завершающий список ключей, используется для файлов, начинающихся с `-`. Т.е. если у вас вдруг файл называется `-file`, то для того, чтобы его перенести, надо использовать синтаксис `mv -- -file /tmp/`.
*   `-n`, `--no-clobber` — не перезаписывать существующие файлы.
*   `-v`, `--verbose` — выводить информацию о каждом файле, который в данный момент обрабатывается с помощью `mv`.
*   `-u`, `--update` — перемещать только при условии, что исходный файл новее, чем конечный, или если конечного файла не существует.

Разберём на примере.

Мы создали файл `text_file`, ввели в него несколько символов и скопировали его в иную директорию, для условности возьмём `/tmp`.

И если теперь попробовать переместить файл в `/tmp/`, используя ключ `-u`, то ничего не произойдёт, файл так и останется на месте. Никаких предупреждений на экран тоже не будет выведено.
```sh
$ mv -u text\_file /tmp/
```
Если откроем исходный `text_file` в редакторе и изменим его каким-либо образом, например, добавив несколько текстовых символов, то после этого файл будет перемещён и заменит конечный файл в директории `/tmp`.

Для переименования файла или директории требуется команда вида:
```sh
$ mv  text\_file\_old text\_file\_new
```
Команда `mv` переносит файлы по следующему принципу: сначала она создаёт новый файл, копирует туда данные, а потом удаляет старый.

## **touch**

Не можем не упомянуть ещё одну команду — `touch`. Она используется для создания пустых файлов, для установки или для изменения времени последнего изменения файла. Чтобы создать пустой файл, надо использовать команду:
```sh
$ touch имя\_файла
```
Для создания файла с определённой датой используется ключ `-d` и дата в формате _ггггммдд_:
```sh
$ touch -d 20201201 имя\_файла
```
## **Подведём итог**

Теперь вы узнали, как удалять, копировать и переносить файлы. Пусть это и кажется незначительной частью, но неаккуратное обращение с `rm` может уничтожить всю операционную систему без возможности восстановления. Помните про это и аккуратно пользуйтесь командами.

# 1.9 Системы поиска
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/b25695377717bfff17dc1f4342a07aaf/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.9.svg)

## **Системы поиска**

Для поиска используются утилиты `grep` и `find`. Поиск по операционной системе без графического интерфейса превращается в невыполнимую миссию. Придётся ходить на чёрном фоне по абсолютно одинаковым директориями и высматривать, какие там есть файлы. Именно по этой причине юнит посвящён работе с этими двумя утилитами.

## **find**

Эта утилита для поиска.

Синтаксис команды такой:
```sh
$ find директория\_поиска \[ключи\]
```
Рассмотрим ключи с примерами для поиска.

`-name` — поиск по имени. Ищет в директории и во всех вложенных директориях.

В данном примере идёт поиск файла, который называется `text_file` во всех директориях системы `/`.
```sh
$ find / -name text\_file
```
Если требуется найти файл, когда известна только часть его имени, то можно использовать маску `*`.

Например, здесь найдутся все файлы, название которых начинается с `text_`:
```sh
$ find / -name “text\_\*”
```
А в данном случае найдутся все файлы, которые заканчиваются на `.conf`:
```sh
$ find / -name “\*.conf”
```
Для команды `find` существуют логические «И» и «ИЛИ»:

*   `-a` — логическое «И». «И» можно использовать, когда известны начало и конец файла.
*   `-o` — логическое «ИЛИ».

Например, команда для поиска `text_file` по двум первым и двум последним символам:
```sh
$ find / -name “te\*” -a -name “\*le”
```
`!` — логический оператор для отрицания.

В этом примере показано, что будут найдены все файлы, кроме тех, в названии которых содержится `text`.
```sh
$ find / ! -name “\*text\*”
```
Файлы можно также искать и по дате, используя ключ `-mtime`.

В этом примере найдутся все файлы, которые изменялись более трёх дней назад:
```sh
$  find / -mtime +3 
```
Ключ `-newermt` позволяет найти файлы по дате изменения.

Данный синтаксис позволит найти все файлы, которые были изменены после 8:54 по времени:
```sh 
$  find / -newermt  "08:54"
```
Но можно также добавлять и даты:
```sh
$   find / -newermt "sep 21"
```
В поиске файлов с помощью ключей _newer_ наиболее популярны:

*   `-newermt` — поиск по времени изменения,
*   `-newerat` — поиск по времени обращения,
*   `-newerct` — поиск по времени создания.

Ключ `-type` отвечает за поиск по типу:

*   `f` — файл,
*   `d` — каталог,
*   `l` — ссылка,
*   `s` — сокет,
*   `p` — канал.

Также полезным ключом является `-exec`, который позволяет выполнять команду над найденными файлами. Например, можно объединить с командами выше.

В данном примере будут удалены все файлы, которые изменены после 21 сентября:

$   find / -newermt "sep 21" -exec rm {} \\;

`{}` — нужно для указания вывода строки списка файлов, которая была найдена по команде поиска.

Командная строка должна завершаться последовательностью символов `\;` Он указывает на конец `exec`.

## **grep**

Искать можно также и по содержимому, используя после `exec` утилиту `grep`. Давайте остановимся на этом подробнее.

`grep` — это утилита, позволяющая проводить поиск строк. С её помощью ищутся конкретные слова в файле, также этой команде можно передать любой вывод для поиска, что упрощает работу.

Синтаксис команды:
```sh
$   grep \[ключи\] строка путь\_к\_файлам
```
Основные ключи к команде, которые чаще всего будут использоваться:

*   `-l`, `--files-with-matches` — выводит имя каждого файла, в котором совпадают данные.
*   `-i`, `--ignore-case` — игнорирование регистра.
*   `-r`, `--recursive` — рекурсивный поиск.
*   `-v` — инвертированный вывод.

Например, открывая файл через `cat` , через пайп (_pipeline_ — конвейер — вертикальная черта `|` используется для множества процессов, когда требуется перенаправление — об этом более подробно будет в следующих модулях), можно передать вывод в `grep`, благодаря чему найти определённые строки.

В этом примере показано, как из файла логов вывести строки, содержащие слово _user._
```sh
$   cat /var/log/auth.log |grep user
```
В данном случае через пайп данные передаются к grep, и он среди них ищет требуемые строки. Можно использовать эту команду иначе, используя только grep:
```sh
$   grep user /var/log/auth.log
```
Вывод данных будет аналогичный.

Допустим, вам надо найти файлы, в которых содержатся определённые строки. Например, вам известен некий параметр файла конфигурации, но вы не знаете, где конкретно находится этот файл. Сейчас представим, что надо найти конфигурационный файл для _ssh,_ с которым мы будем работать в следующих модулях. Мы не знаем, где он лежит, но знаем точно, что он настроен сейчас на 22 порт.

Для поиска можно использовать команду grep с синтаксисом:
```sh
$   grep -rl “Port 22” /etc/
```
Где ключ `-r` отвечает за то, что это будет рекурсивный поиск, а ключ `-l` за то, чтобы выводились не просто строки, а пути к файлам, где эти строки находятся. Т. к. в `Port 22` есть пробел, то фразу надо брать в кавычки, двойные или одинарные, иначе команда не сработает, и он будет пытаться найти строку _Port_ в файле 22, которого не существует.

Но чаще всего придётся использовать grep как фильтр для поиска определённых строк в текстовых файлах.

## **ls**

Также стоит рассказать про команду `ls`. Синтаксис её привычен по предыдущим примерам:
```sh
$   ls \[ключи\] \[директория\]
```
Если вывести команду ls без ключей или аргументов, то она покажет в командной строке все файлы, которые находятся в текущей директории, т. к. там вы находитесь.

Посмотрим, что есть в директориях. Это можно сделать, не переходя в другие директории. Например, чтобы посмотреть, что находится в директории `/var/log`, достаточно команды с таким синтаксисом:
```sh
$   ls /var/log
```
И вы увидите список файлов, которые есть в данной директории.

Основные ключи к команде, которые пригодятся на данном этапе, это:

*   `-a`, `--all` — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.
*   `--help` — выдавать инструкции по команде.

В следующем модуле вы узнаете список ключей к этой команде, когда начнётся работа с правами и группами, потому что эта утилита рассчитана на то, чтобы просматривать их у файлов, а пока не будем никого путать.

## **Подведём итог**

В этом юните вы ознакомились с поиском по файлам и с поиском самих файлов.

Если перед вами вдруг встанет проблема, что вы не знаете, где на сервере прописан _NS-_сервер, но знаете его точный _IP-_адрес, то вы всегда можете воспользоваться поиском. Или в файле больше тысячи строк, а вам нужно найти только одну по определённым символам, то всегда поможет старый добрый `grep`. Файлы в директории всегда поможет просмотреть `ls`.

# 1.10. Подведём итоги
![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/3019e5744106859f7744325712592fdb/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_open_1.10.svg)

## **Подведём итоги**

**В этом модуле вы узнали:**
*   Краткую справку по _Linux._
*   Зачем нужны мануалы и как ими пользоваться.
*   Как работать с директориями и какие основные типы директорий существуют.
*   Как правильно читать файлы и перемещаться по ним.
*   Как редактировать файлы и работать с _vi._
*   Как удалять, создавать и копировать файлы.
*   Как искать файлы и строки в файлах.
---
После выполнения заданий вы уже не будете опасаться странных белых символов на чёрном фоне.

### **Дополнительные материалы**

*   [20 приёмов работы в командной строке Linux, которые сэкономят уйму времени](https://habr.com/ru/company/ruvds/blog/339820/),
*   Книга **Linux для «чайников»**, автор Ди-Анн Лебланк.

### **Список команд**

<table>
<tbody>
<tr>
<td style="text-align: center;" width="20%">find</span></td>
<td style="text-align: left;">поиск</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">grep</span></td>
<td style="text-align: left;">фильтр</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">ls</span></td>
<td style="text-align: left;">просмотр файлов в директории</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">mv</span></td>
<td style="text-align: left;">перенос или переименование файлов</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">rm</span></td>
<td style="text-align: left;">удаление файлов</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">cp</span></td>
<td style="text-align: left;">копирование файлов</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">touch</span></td>
<td style="text-align: left;">создание файлов</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">vi</span></td>
<td style="text-align: left;">текстовый редактор <em>vi</em></span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">nano</span></td>
<td style="text-align: left;">текстовый редактор <em>nano</em></span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">cat</span></td>
<td style="text-align: left;">вывод всего текстового файла</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">head</span></td>
<td style="text-align: left;">вывод начала текстового файла</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">tail</span></td>
<td style="text-align: left;">вывод конца текстового файла</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">less</span></td>
<td style="text-align: left;">постраничное чтение файла</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">cd</span></td>
<td style="text-align: left;">переход в требуемую директорию</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">pwd</span></td>
<td style="text-align: left;">показывает, в какой директории вы в данный момент находитесь</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">mkdir</span></td>
<td style="text-align: left;">создание директории</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">rmdir</span></td>
<td style="text-align: left;">удаление директории</span></td>
</tr>
<tr>
<td style="text-align: center;" width="20%">man</span></td>
<td style="text-align: left;">мануал</span></td>
</tr>
</tbody>
</table>